# Minion Reference

## Introduction

To use Minion, your makefile include `minion.mk` *after* defining all
Minion-related definitions (usually at the last line in the makefule).

The file minion.mk is self-contained; it depends on no other files.  Minion
is tested with GNU Make v3.81.

If you invoke make without any arguments, Minion will attempt to build a
target named `default`, which your makefile may define using an *alias*
(described below) or an ordinary Make rule.

If you pass arguments on the command line, Minion will treat the arguments
as a set of goals to be built, and will build them.  Each goal may be one of
the following:

  * An ordinary Make target
  * An [*instance*](#instances).
  * An [*indirection*](#indirections).
  * An [*alias*](#aliases).

If you invoke make with `help` as one of the goals, Minion will output a
description of the other goals, rather than build them.


## Ingredients

Within your makefile, each file that is an input to (prerequisite for) a
Minion-generated target is identified by one of the following kinds of
**target IDs**:

1. The name of the file.  This will be the case when naming a source file
   or a file generated by an ordinary Make rule.

2. The [*instance*](#instances) that generates the file.  This will be the
   case for files generated by Minion rules.

An **ingredients list** is a space-delimited list of IDs or
[*indirections*](#indirections).  Each indirection will be expanded to zero
or more IDs.


## Instances

An **instance** is an expression that takes the form: `CLASS(ARGS)`.

Instances describe build steps for which Minion generates all the required
Make rules.  For example, `CC(hello.c)` describes the build step of
compiling `hello.c` to generate an object file.  Typing `make 'CC(hello.c)'`
will build the object file, and using `CC(hello.c)` in an ingredient list
will identify the object file as an input and prerequisite.


## Aliases

Aliases are names that may be used on the command line as goals.

If your makefile defines a variable named `Alias(NAME).in` or
`Alias(NAME).command`, then `NAME` is a valid *alias*.  The value of the
`.in` variable, if defined, is an ingredient list that identifies what the
alias will cause to be built.  The value of the `.command` variable, if
defined, is a shell command to be executed when the alias is named as a
goal.  If both are defined, the command will be executed after all the
ingredients are buit.

When defined, `Alias(NAME)` is a valid instance, so `make NAME` is really
just a shorthand for `make 'Alias(NAME)'`.  Alias names can be specified as
*goals* (that is, on the make command line), but they are not supported in
ingredient lists (in your makefile).  If you want to make use of an alias
definition in an ingredient list, you can use its instance name.  For
example:

   Alias(all).in = Alias(default) Alias(tests)


## Indirections

An **indirection** is an expression that takes the form `@VAR` or
`CLASS@VAR`.

Indirections may appear in [ingredient lists](#ingredients) or on the
command line.  When Minion examines a goal or an ingredient list, it
performs an expansion step, replacing indirections with the files/instances
they reference.  The result of this expansion is zero or more instances or
file names.

The two forms are called "simple" and "mapped":

 - `@VAR`      : a simple indirection
 - `CLASS@VAR` : a mapped indirection

A *simple* indirection expands to the value of the variable `VAR`.  That value
might contain other indirections, in which case they will be expanded
recursively.

A *mapped* indirection applies the `CLASS` constructor individually to the
names resulting from the expansion of `@VAR`.  For example, if `@sources`
expands to `a.c b.c`, then `CC@sources` will expand to `CC(a.c) CC(b.c)`.

Mapped indirections can also use a "chained" syntax to apply two or more
classes at once.  Using the same `sources` variable as in the example above,
the indirection `LinkC@CC@sources` would expand to `LinkC(CC(a.c))
LinkC(CC(b.c))`.

Indirections may not contain the characters `(` or `)`.  For example, the
instance `Link(CC@sources)` is not treated as an indirection, and it will
not be altered during the expansion step.  Its argument, `CC@sources`, *is*
an indirection, so when the inputs for `Link(CC@sources)` are computed the
result will be `CC(a.c) CC(b.c)`.


## Classes

The behavior of an instance is determined by a set of **properties** that are
computed for the instance.  Property definitions are stored in Make variables
whose names take the form `CLASS.PROPERTY` or `CLASS(ARGS).PROPERTY`, with
the latter, instance-specific form taking precedence if both are defined.

Each class can inherit definitions from other classes.  A variable named
`CLASS.inherit`, if defined, is a space-delimited list of classes from which
definitions will be inherited.  When Minion is computing a property, if it
finds no definition for that property associated with its instance name or
its class name, then it will look for a definition of that property
associated with one of the inherited class names.  It examines them in
order, using the first definition it finds.  An inherited class can, in
turn, inherit from other classes.

The values associated with definitions can, as with ordinary Make variables,
use `$(...)` to substitute Make variables and call functions.  However, they
may not use `${...}`, because `{` and `}` are reserved for Minion-specific
functionality.  Expressions of the form `{...}` expand to the value of the
property named by `...`.  The string `{inherit}` expands to the inherited
value of the property currently being evaluated -- the value it *would have*
taken on if the current definition had not been present.  To include an
actual `{` or `}` character in a property definition, use `$([[)` or
`$(]])`.

While a property definition is being expanded, various [functions and
variables exported by Minion](#exported-definitions) are available for use.
These can be used directly within a property definition, or within a
function or variable that is referenced by a property definition.

Minion property evaluation is memoized, so each property definition is
expanded no more than once for each instance.

Note that instances have no associated "state".  All property definitions
are purely functional in nature.  As such, there is no notion of "creating"
or "destroying" instances.  We cannot say whether an instance "exists" in a
makefile or not ... but we can talk about whether it is *mentioned* in a
goal or an ingredient list.  You can think of a class as a function --
somewhat elaborate and multifacted, but ultimately a function -- that yields
a set of property definitions.  An instance identifies the function (class)
and its inputs (argument list).

### "Simple" Definitions

Make supports two "flavors" of variables, "simple" (using `:=`) and
"recursive" (using `=`).  The above discussion assumes that properties are
defined using recursive (`=`) assignments.  Properties *may* be defined
using simple assignments.  With `:=`, values are expanded when and where the
assignment appears (prior to inclusion of `minion.mk`), so they may not make
use of `{...}` syntax or Minion exported functions and variables.


## Argument Lists

An instance's **argument list** may contain multiple comma-delimited values,
each with an optional `NAME:` prefix.  Arguments without such a prefix are
called "unnamed arguments".  For example, `Link(a.o,b.o)` has an argument
list with two unnamed values.  `Copy(@program,out:deploy/program)` has one
unnamed argument and one named argument.

Remember that argument lists, being part of an instance, may not contain
whitespace.

Within a property definition, the `_args` variable and the `_namedArgs` and
`_namedArg1` functions, described [below](#exported-definitions), can be
used to access the named and unnamed arguments of the current instance.


## Cached Rules

Ordinarily, every time you invoke `make`, Minion computes the `rule`
property for all goals and their transitive dependencies prior to Make's
rule processing phase.  If your makefile describes hundreds or thousands of
build steps, this can take a perceptible amount of time.  To accelerate
incremental builds, Minion can write many or all of its generated rules to a
"cache" file, and avoid re-computing them every time `make` is invoked.

To enable caching, assign to the variable `minion_cache` an [ingredient
list](#ingredients) that identifies the instances to be cached.  All of the
rules of the referenced instances and their transitive dependencies will be
written to a cache file.

When using `minion_cache`, you can still build either cached or uncached
goals.  Minion will use cached rules when they are present, and dynamically
generate any other required rules.

The cache file will be re-generated whenever your makefile changes, so
generally the results of building with cached rules will be the same as when
you build without cached rules.  However, if the commands in your build
steps depend on the dynamic state of the system, then the cached rules will
reflect those values as of the time when the cache file was generated, which
may differ from what those values are when you invoke make.

One such scenario occurs when you override variables on the Make command
line in order to perform a one-off customized build.  When doing so, you can
also set `minion_cache` to the empty string to perform that build without
caching, avoiding any problems with stale cached rules.  For example:

    $ make CC.optFlags=-Ot minion_cache=

Another such scenario occurs when you have instances whose commands or
inputs may vary according to information pulled from the system via, for
example, `$(wildcard ...)` or `$(shell ...)`.  When this is the case, you
can list those specific instances in the variable `minion_cache_exclude`, so
that their rules will be excluded from the cache file and instead be
generated each time you invoke make.  For example:

    ...
    minion_cache = Alias(default)
    minion_cache_exclude = LinkC(@prog)
    ...
    prog = $(wildcard *.c)
    ...

Note that whereas `minion_cache` implicitly includes all transitive
dependencies of the listed instances, `minion_cache_exclude` does not.  It
is intended to target individual build steps.


## Builders

All instances being built must implement this interface.  It consists of
just three properties:

 * `rule` : a string of Make source code, that, when eval'ed, will define a
   Make rule for the instance.

 * `out`: the resulting file path, or phony target name.

 * `needs`: an ingredients list giving the prerequisites of `rule`.

User-defined classes do not need to implement these directly.  Instead, they
should inherit from `Builder`.

## Builder

`Builder` is a built-in class that implements the builder interface and
handles a number of low-level responsibilities, including the following:

 * An output file name and location is computed.

 * Inputs are obtained from the unnamed arguments.

 * The build command is escaped for Make syntax to avoid unintended
   evaluation, and the output file's directory is created prior to execution
   of the command.

 * After changes to makefiles affect the way artifacts are built, the
   affected artifacts (and only those) will be rebuilt.  See (validity
   values)[#validity-values].

Subclasses can leverage this functionality by inheriting from Builder, and
can then customize their functionality by defining or overriding properties.

### `{command}`

Subclasses of Builder must provide a definition for the `command` property.
Builder will provide defaults for all other properties.  The value is one or
more shell commands separated by newline characters.  Its definition may
make use of the following property references:

 * `{@}`: the output file
 * `{<}`: the first input file
 * `{^}`: all input files

These properties correspond to Make's "automatic variables" `$@`, `$<`, and
`$^`, which are unavailable in Minion property definitions, since command
expansion happens prior to the rule processing phase.  The value of `{^}` is
not identical to Make's `$^`, but it is more often what you want: it is a
list of the *input* files, which are derived from the ingredients named in
the `{in}` property, which defaults to `$(_args)`.  By contrast, make's `$^`
includes all prerequisites, which may include tools, implied dependencies,
and other files that would not normally appear as command line arguments.

For example, the `Tar` class inherits this definition of `command`:

    _Tar.command = tar -cvf {@} {^}

### `{outExt}`

Most subclasses of `Builder` will define `{outExt}`, which specifies the
extension (including the ".") that the output file will have.  Any `%`
character in `{outExt}` will be replaced with the extension of the first
input file.  Builder.outExt is defined as `%`, so by default the output file
will have the same extension as the first input file.

For example, `Tar` outputs files with a `.tar` extension, so it defines:

    _Tar.outExt = .tar

### `{in}`

The value of `{in}` is an [ingredient list](#ingredients).

Typically, the arguments to an instance name its inputs, so `in` defaults to
`$(_args)`, which evaluates to all unnamed arguments.  Classes that are
exceptions to this rule, such as `Alias` and `MkDir`, override this property.

Ingredients listed in `{in}` will be treated as pre-requisites of the
instance's rule.  The output files for all ingredients listed in `{in}` are
available as `{^}`, and `{<}` holds the first of them.

### `{out}` and related properties

The value of `{out}` is a file path.  It identifies the file that is
generated by the instance, or, in the case of phony instances, the phony
target name.

We generally rely on Builder's definition of `{out}`, which provides a
number of finer-grained opportunities for customization:

 * `{outExt}`: This is the extension to replace the input file's extension
   when constructing the output file name.  A `%` in `{outExt}` is replaced
   with the extension of the input file name.

 * `{outDir}`: By default, this identifies a directory that is underneath
   `$(OUTDIR)`.

 * `{outName}`: By default, this is constructed from `{outExt}` and the
   input file name.  The input file name is taken from the `{out}` property
   of the first input to the instance, unless the instance's first argument
   is an indirection, in which case the indirection variable name is used.

When using Minion, we generally don't care where intermediate output files
are located, since we refer to them by their instance names.  As a result,
most derived classes override only `{outExt}` and leave the other properties
unchanged.

Note that Builder's definition of `{out}` is designed to ensure that
different instances will not generate conflicting output file paths.  Its
directory components incorporate the class name and all the arguments.  When
overriding `{outDir}`, `{outName}`, or `{out}` itself, keep in mind that no
two instances can share the same output file name.  Also, be aware that
Minion's `make clean` simply executes `rm -rf $(OUTDIR)`, so it will not
remove any output files whose `{out}` properties have placed them outside of
`$(OUTDIR)`.

The `Mkdir` class has no input files, and uses its first argument to specify
the *output* name.  It inherits this from `_Mkdir`:

    _Mkdir.in =
    _Mkdir.out = $(_arg1)

The `Copy` class exists to deploy files to a specific, well-known location,
rather than an automatically-generated unique location, so it allows the
output file location to be specified by an argument with the name `out`:

    _Copy.out = $(or $(call _namedArg1,out),{inherit})

For example, `Copy(CC(foo.c),out:deploy/foo.o)` will place its result in
"deploy/foo.o".

### `{up}`

An instance may have dependencies that are not specified by the user via
arguments or the `in` property, and instead are built into the definition of
the class.  An example is when a build step uses a tool that is itself a
build product.  We would prefer the dependency on the tool to be "baked
into" the class definition, so when using the class one needs to name only
the files that will be processed by the tool.  This is akin to the notion of
captured values in lexically scoped programming languages.  These built-in
dependencies are stored in the `up` property, which is an [ingredient
list](#ingredients).  The property `up^` evaluates to the output file names
obtained from the ingredients in `up`, analogously to how `^` is computed
from `in`.

### `{oo}`

Order-only dependencies can be specified by defining the `oo` property (an
[ingredient list](#ingredients)).  This type of dependency can be
appropriate when we know there is a dependency on the existence of a file,
but not necessarily on the content of the file.

Order-only dependencies are typically used to deal with *implied
dependencies* that need to be generated by the Makefile.

Implied dependencies are files that are not specified on the command line,
but are read during execution of the build command.  The classic example is
files included by C sources using `#include`.  In Make, implied dependencies
are trakced using the following strategy:

 a) The command that compiles the C file also generates a dependency
    makefile expressing dependencies of the output file on the files that
    were included.

 b) An `-include` directive is used to include the dependency makefile if
    it has already been generated by a previous invocation of Make.

Minion's `CC` and `CC++` clases implement this strategy.  This ensures
accurate *rebuilds* of object files when included headers are modified.

Order-only dependencies enter the picture when some of the implied
dependencies are generated by our makefile.  When we are building an object
file for the first time, we do not know beforehand what include files will
be included, so we need to ensure that any *potential* dependencies are
generated before it is compiled.  The solution is to name all generated
header files as order-only dependencies of all object files.  It might look
something like this:

   CC.oo = IDLCompile@idlFiles

### `{inferClasses}`

Rule inference is performed on input files.  Each class can define its own
inference rules by overriding `{inferClasses}`.  This consists of a list of
entries of the form `CLASS.EXT`, each indicating that `CLASS` should be
applied to a input file ending in `.EXT`.

For example, inference allows a ".c" file to be supplied where a ".o" file
is expected.  The instance `LinkC(hello.c)` will infer the instance
`CC(hello.c)`, because `LinkC.inferClasses` contains `CC.c`.


### Validity Values

By default, the *command* used to build a Minion target is treated as a
dependency of the target.  That is, if any changes to makefiles result in
changes to the build command, any previous build results will be considered
stale, and will be rebuilt the next time they are freshened with `make`.

This behavior is controlled by `{vvFile}`, which identifies a makefile that
will store the command used to generate `{out}`.  If `{vvFile}` is empty,
this validity check is disabled.  Builder provides a value for `{vvFile}`
that is underneath `$(OUTDIR)`.  Phony targets disable this feature because
they are always treated as stale.  User makefiles can disable this on a
per-instance or per-class basis by overriding `{vvFile}`, and they can
disable it globally by setting `Builder.vvFile` to the empty string.


## Exported Definitions

Minion defines a number of variables and functions for use by user Makefiles
within recursive property definitions.

* Character constants

  - `$(\n)`: newline
  - `$(\t)`: tab
  - `$(\s)`: space
  - `$;` : `,`
  - `$[` : `(`
  - `$]` : `)`
  - `$([[)`: `{`
  - `$(]])`: `}`
  - `$(\H)`: `#`

* `$(call get,PROP,IDS)`

  Evaluate property PROP for each member of IDS.  IDS is a space-delimited
  list of IDs.  The result is a space-delimited list of the corresponding
  values.

  If a file name (not an instance name) is passed to `get`, it will be
  treated as an instances of the `_File` class.  This defines the property
  `out`, which evaluates to the file name, and the properties `rule` and
  `needs`, which are empty.

* `$(call .,PROP,$0)`

  Evaluate property PROP for the current instance.  In property definitions,
  `$(call .,PROP,$0)` is equivalent to `{PROP}`.  In other variables and
  functions, `{...}` syntax is not supported, but `.` is available if they
  are called during the evaluation of a property definition.  The second
  argument is used to construct a diagnostic message only in the event PROP
  is undefined.  It should be the name of the function calling `.`, which is
  available in Make as `$0`.

* `$(call _shellQuote,STR)`

  Quote STR as an argument for /bin/sh or /bin/bash.

* `$(call _printfEsc,STR)`

  Escape STR for inclusion in a `printf` format string on a command line.

* `$(call _printf,STR)`

  Return a shell command that writes STR to stdout.

* `$(call _eq,A,B)`

  Return "1" if A and B are equal, "" otherwise.

* `$(call _once,VAR)`

  Return the value of VAR, evaluating it at most once.

* `$(_self)`

  Return the name of the current instance.

* `$(_class)`

  Return the class of the current instance.

* `$(_argText)`

  Return the portion of the current instance name that describes the
  argument list.

  For example, in `Class(a,b,x:1,x:2)`, `$(_argText)` returns "a,b,x:1,x:2".

* `$(_args)`

  Return all unnamed arguments for the current instance.

  For example, in `Class(a,b,x:1,x:2)`, `$(_args)` returns "a b".

* `$(_arg1)`

  Same as `$(word 1,$(_args))`.

* `$(call _namedArgs,NAME)`

  Return all arguments associated with NAME for the current instance.

  For example, in `Class(a,b,x:1,x:2)`, `$(call _namedArgs,x)` returns "1 2".

* `$(call _namedArg1,NAME)`

  Same as `$(word 1,$(call _namedArgs,NAME))`.

* `$(call _relpath,FROM,TO)`

  Construct a path that can be used to refer to file `TO` from file `FROM`.
  If `TO` is an absolute path, it is returned as the result.  Otherwise, both
  `FROM` must be a relative path and the result will be a relative path.


## Syntax

A target ID is either a `Name` (identifying a source file or target of a
Make rule) or an `Instance`.

Names avoids characters that are interpreted by POSIX shells or GNU Make as
special, except for `~`, which is interpreted similarly by both.  As a
result, there should be no need for special quoting or escaping of file
names in commands.

The following BNF describes target names:

    TargetID := Name | Instance
    Instance := Class '(' ArgList ')'
    ArgList  := ( Arg ( ',' Arg )* )?
    Arg      := ( Name `:` )? Value
    Value    := ( Instance | Name | Property )+
    Name     := NameChar+
    Class    := ClassChar+
    Property := PropChar+

These definitions rely on the following character classes:

    ClassChar:  A-Z a-z 0-9 _ - + / ^ ~ { }
    NameChar:   A-Z a-z 0-9 _ - + / ^ ~ { } .
    PropChar:   A-Z a-z 0-9 _ - + / ^ ~       @ < >

Note that an argument list contains zero or more arguments, and each
argument must contain at least one character.  Each argument may contain
other instances embedded within it, which means it may contain `(` and `)`,
characters, but only in balanced pairs.  An argument may also contain `,`
and `:`, but only within nested parentheses.

In general, instances will contain special shell characters, so they may
have to be quoted when being passed on the command line.
